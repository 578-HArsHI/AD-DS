#include <iostream.h>
#include <conio.h>
#include <iomanip.h>
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int info;
	node *left, *right;
}*root;
int rv = 0;
class BST
{
	public:
		void insert(node *, int);
		void inorder(node *);
		void preorder(node *);
		void postorder(node *);
		void display(node *, int);
		void search(int, node **, node **);
		void delete_node(int, node **, node **);
		BST()
		{
			root = NULL;
		}
};
void main()
{
	clrscr();
	int choice, num , ele;
	BST bst;
	node *temp1, *temp2;
	do
	{
		cout<<"--------------------------------"<<endl;
		cout<<"OPERATIONS ON BINARY SEARCH TREE"<<endl;
		cout<<"--------------------------------"<<endl;
		cout<<"1.INSERT\t";
		cout<<"2.SEARCH\t";
		cout<<"3.DELETE"<<endl;
		cout<<"4.DISPLAY\t";
		cout<<"5.EXIT\t\t";
		cout<<"Enter your choice : ";
		cin>>choice;
		switch(choice)
		{
			case 1:	cout<<"Enter the element to be inserted : ";
				cin>>ele;
				bst.insert(root, ele);
				break;
			case 2:	if (root == NULL)
					cout<<"TREE IS EMPTY...???"<<endl;
				else
				{
					cout<<"Enter the element to be searched : ";
					cin>>ele;
					bst.search(ele,&temp1,&temp2);
					cout<<temp1->info<<" "<<temp2->info<<endl;
					if(temp1->info == 0)
						cout<<temp2->info<<" FOUND AT ROOT"<<endl;
					else if(temp2->info < temp1->info)
						cout<<temp2->info<<" FOUND AT LEFT OF "<<temp1->info<<endl;
					else if(temp2->info > temp1->info)
						cout<<temp2->info<<" FOUND AT RIGHT OF "<<temp1->info<<endl;
				}
				break;
			case 3:	if (root == NULL)
					cout<<"TREE IS EMPTY...???"<<endl;
				else
				{
					cout<<"Enter the element to be deleted : ";
					cin>>ele;
					bst.delete_node(ele,&temp1,&temp2);
					cout<<temp1->info<<" "<<temp2->info<<endl;
				}
				break;
			case 4:	if (root == NULL)
					cout<<"TREE IS EMPTY...???"<<endl;
				else
				{
					bst.display(root,1);cout<<endl;cout<<endl;
					cout<<"INORDER : ";bst.inorder(root);cout<<endl;
					cout<<"PREORDER : ";bst.preorder(root);cout<<endl;
					cout<<"POSTORDER : ";bst.postorder(root);cout<<endl;
				}
				break;
			case 5:	cout<<"SUCCESSFULLY EXITED"<<endl;
				exit(1);
			default:cout<<"WRONG CHOICE...!!!"<<endl;
		}
	}
	while(choice != 5);
	getch();
}
void BST::insert(node *ptr, int value)
{
	if (root == NULL)
	{
		root = new node;
		root->info = value;
		root->left = NULL;
		root->right = NULL;
		cout<<root->info<<" ENTERD AS ROOT"<<endl;
	}
	else if (value < ptr->info)
	{
		rv = ptr->info;
		if (ptr->left != NULL)
		{
			insert(ptr->left, value);
		}
		else
		{
			ptr->left = new node;
			ptr = ptr->left;
			ptr->info = value;
			ptr->left = NULL;
			ptr->right = NULL;
			cout<<ptr->info<<" ENTERED AS LEFT OF "<<rv<<endl;
		}
	}
	else if (value > ptr->info)
	{
		rv = ptr->info;
		if (ptr->right != NULL)
		{
			insert(ptr->right, value);
		}
		else
		{
			ptr->right = new node;
			ptr = ptr->right;
			ptr->info = value;
			ptr->left = NULL;
			ptr->right = NULL;
			cout<<ptr->info<<" ENTERED AS RIGHT OF "<<rv<<endl;
		}
	}
	else if (value == ptr->info)
	{
		if(value == root->info)
			cout<<value<<" ALREADY ENTERED IN ROOT"<<endl;
		else if(value < rv)
			cout<<value<<" ALREADY ENTERED IN LEFT OF "<<rv<<endl;
		else if(value > rv)
			cout<<value<<" ALREADY ENTERED IN RIGHT OF "<<rv<<endl;
	}
}
void BST::search(int item, node **par, node **loc)
{
	node *ptr1, *ptr2;
	if (item == root->info)
	{
		*loc = root;
		*par = NULL;
		return;
	}
	else if (item < root->info)
		ptr1 = root->left;
	else
		ptr1 = root->right;
	ptr2 = root;
	while (ptr1 != NULL)
	{
		if (item == ptr1->info)
		{
			*loc = ptr1;
			*par = ptr2;
			return;
		}
		ptr2 = ptr1;
		if (item < ptr1->info)
			ptr1 = ptr1->left;
		else
			ptr1 = ptr1->right;
	}
	*loc = NULL;
	*par = ptr2;
}
void BST::delete_node(int item, node **par, node **loc)
{
	node *ptr1, *ptr2;
	int flag = 0;
	ptr1 = root;
	while(ptr1 != NULL)
		{
			if (item < ptr1->info)
			{
				ptr2 = ptr1;
				ptr1 = ptr1->left;
			}
			else if (item > ptr1->info)
			{
				ptr2 = ptr1;
				ptr1 = ptr1->right;
			}
			else if (item == ptr1->info)
			{
				flag++;
				if(ptr1->info == root->info && flag == 1)
				{cout<<ptr1->info<<" FOUND AT ROOT"<<endl;}
				else if(ptr1->info <= ptr2->info)
				{cout<<ptr1->info<<" FOUND AT LEFT OF "<<ptr2->info<<endl;}
				else if(ptr1->info > ptr2->info)
				{cout<<ptr1->info<<" FOUND AT RIGHT OF "<<ptr2->info<<endl;}
				ptr2 = ptr1;
				ptr1 = ptr1->left;
			}
		}
		if (flag == 1)
		{
			cout<<ptr1->info<<" FOUND ROOT"<<endl;
			*par = ptr2;
			*loc = ptr1;
			return;
		}
		else if (flag >= 1)
		{
			cout<<ptr1->info<<" FOUND CHILD"<<endl;
			*par = ptr2;
			*loc = ptr1;
			return;
		}
		else
			cout<<ptr1->info<<" NOT FOUND"<<endl;
}
void BST::display(node *ptr, int level)
{
	if (ptr != NULL)
	{
		display(ptr->right, level+1);
		cout<<endl;
		if (ptr == root)
			cout<<"ROOT->:  ";
		else
		{
			for (int i = 0;i < level;i++)
				cout<<"          ";
		}
		cout<<ptr->info;
		display(ptr->left, level+1);
	}
}
void BST::preorder(node *ptr)
{
	if (ptr != NULL)
	{
		cout<<ptr->info<<" ";
		preorder(ptr->left);
		preorder(ptr->right);
	}
}
void BST::inorder(node *ptr)
{
	if (ptr != NULL)
    	{
		inorder(ptr->left);
		cout<<ptr->info<<" ";
		inorder(ptr->right);
	}
}
void BST::postorder(node *ptr)
{
	if (ptr != NULL)
	{
		postorder(ptr->left);
		postorder(ptr->right);
		cout<<ptr->info<<" ";
	}
}